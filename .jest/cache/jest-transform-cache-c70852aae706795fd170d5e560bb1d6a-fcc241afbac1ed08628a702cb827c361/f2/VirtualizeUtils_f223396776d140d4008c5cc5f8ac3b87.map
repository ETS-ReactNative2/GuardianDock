{"version":3,"sources":["VirtualizeUtils.js"],"names":["elementsThatOverlapOffsets","offsets","itemCount","getFrameMetrics","out","outLength","ii","frame","trailingOffset","offset","length","kk","JSON","stringify","newRangeCount","prev","next","last","first","Math","max","min","computeWindowedRenderLimits","data","getItemCount","maxToRenderPerBatch","windowSize","getFrameMetricsApprox","scrollMetrics","velocity","visibleLength","visibleBegin","visibleEnd","overscanLength","leadFactor","fillPreference","overscanBegin","overscanEnd","lastItemOffset","overscanFirst","overscanLast","visible","newCellCount","maxNewCells","firstWillAddMore","firstShouldIncrement","lastWillAddMore","lastShouldIncrement","Error","keyExtractor","item","index","key","id","String"],"mappings":"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","sourcesContent":["/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @flow\n * @format\n */\n\n'use strict';\n\nimport invariant from 'invariant';\n\n/**\n * Used to find the indices of the frames that overlap the given offsets. Useful for finding the\n * items that bound different windows of content, such as the visible area or the buffered overscan\n * area.\n */\nexport function elementsThatOverlapOffsets(\n  offsets: Array<number>,\n  itemCount: number,\n  getFrameMetrics: (\n    index: number,\n  ) => {\n    length: number,\n    offset: number,\n    ...\n  },\n): Array<number> {\n  const out = [];\n  let outLength = 0;\n  for (let ii = 0; ii < itemCount; ii++) {\n    const frame = getFrameMetrics(ii);\n    const trailingOffset = frame.offset + frame.length;\n    for (let kk = 0; kk < offsets.length; kk++) {\n      if (out[kk] == null && trailingOffset >= offsets[kk]) {\n        out[kk] = ii;\n        outLength++;\n        if (kk === offsets.length - 1) {\n          invariant(\n            outLength === offsets.length,\n            'bad offsets input, should be in increasing order: %s',\n            JSON.stringify(offsets),\n          );\n          return out;\n        }\n      }\n    }\n  }\n  return out;\n}\n\n/**\n * Computes the number of elements in the `next` range that are new compared to the `prev` range.\n * Handy for calculating how many new items will be rendered when the render window changes so we\n * can restrict the number of new items render at once so that content can appear on the screen\n * faster.\n */\nexport function newRangeCount(\n  prev: {\n    first: number,\n    last: number,\n    ...\n  },\n  next: {\n    first: number,\n    last: number,\n    ...\n  },\n): number {\n  return (\n    next.last -\n    next.first +\n    1 -\n    Math.max(\n      0,\n      1 + Math.min(next.last, prev.last) - Math.max(next.first, prev.first),\n    )\n  );\n}\n\n/**\n * Custom logic for determining which items should be rendered given the current frame and scroll\n * metrics, as well as the previous render state. The algorithm may evolve over time, but generally\n * prioritizes the visible area first, then expands that with overscan regions ahead and behind,\n * biased in the direction of scroll.\n */\nexport function computeWindowedRenderLimits(\n  data: any,\n  getItemCount: (data: any) => number,\n  maxToRenderPerBatch: number,\n  windowSize: number,\n  prev: {\n    first: number,\n    last: number,\n    ...\n  },\n  getFrameMetricsApprox: (\n    index: number,\n  ) => {\n    length: number,\n    offset: number,\n    ...\n  },\n  scrollMetrics: {\n    dt: number,\n    offset: number,\n    velocity: number,\n    visibleLength: number,\n    ...\n  },\n): {\n  first: number,\n  last: number,\n  ...\n} {\n  const itemCount = getItemCount(data);\n  if (itemCount === 0) {\n    return prev;\n  }\n  const {offset, velocity, visibleLength} = scrollMetrics;\n\n  // Start with visible area, then compute maximum overscan region by expanding from there, biased\n  // in the direction of scroll. Total overscan area is capped, which should cap memory consumption\n  // too.\n  const visibleBegin = Math.max(0, offset);\n  const visibleEnd = visibleBegin + visibleLength;\n  const overscanLength = (windowSize - 1) * visibleLength;\n\n  // Considering velocity seems to introduce more churn than it's worth.\n  const leadFactor = 0.5; // Math.max(0, Math.min(1, velocity / 25 + 0.5));\n\n  const fillPreference =\n    velocity > 1 ? 'after' : velocity < -1 ? 'before' : 'none';\n\n  const overscanBegin = Math.max(\n    0,\n    visibleBegin - (1 - leadFactor) * overscanLength,\n  );\n  const overscanEnd = Math.max(0, visibleEnd + leadFactor * overscanLength);\n\n  const lastItemOffset = getFrameMetricsApprox(itemCount - 1).offset;\n  if (lastItemOffset < overscanBegin) {\n    // Entire list is before our overscan window\n    return {\n      first: Math.max(0, itemCount - 1 - maxToRenderPerBatch),\n      last: itemCount - 1,\n    };\n  }\n\n  // Find the indices that correspond to the items at the render boundaries we're targeting.\n  let [overscanFirst, first, last, overscanLast] = elementsThatOverlapOffsets(\n    [overscanBegin, visibleBegin, visibleEnd, overscanEnd],\n    itemCount,\n    getFrameMetricsApprox,\n  );\n  overscanFirst = overscanFirst == null ? 0 : overscanFirst;\n  first = first == null ? Math.max(0, overscanFirst) : first;\n  overscanLast = overscanLast == null ? itemCount - 1 : overscanLast;\n  last =\n    last == null\n      ? Math.min(overscanLast, first + maxToRenderPerBatch - 1)\n      : last;\n  const visible = {first, last};\n\n  // We want to limit the number of new cells we're rendering per batch so that we can fill the\n  // content on the screen quickly. If we rendered the entire overscan window at once, the user\n  // could be staring at white space for a long time waiting for a bunch of offscreen content to\n  // render.\n  let newCellCount = newRangeCount(prev, visible);\n\n  while (true) {\n    if (first <= overscanFirst && last >= overscanLast) {\n      // If we fill the entire overscan range, we're done.\n      break;\n    }\n    const maxNewCells = newCellCount >= maxToRenderPerBatch;\n    const firstWillAddMore = first <= prev.first || first > prev.last;\n    const firstShouldIncrement =\n      first > overscanFirst && (!maxNewCells || !firstWillAddMore);\n    const lastWillAddMore = last >= prev.last || last < prev.first;\n    const lastShouldIncrement =\n      last < overscanLast && (!maxNewCells || !lastWillAddMore);\n    if (maxNewCells && !firstShouldIncrement && !lastShouldIncrement) {\n      // We only want to stop if we've hit maxNewCells AND we cannot increment first or last\n      // without rendering new items. This let's us preserve as many already rendered items as\n      // possible, reducing render churn and keeping the rendered overscan range as large as\n      // possible.\n      break;\n    }\n    if (\n      firstShouldIncrement &&\n      !(fillPreference === 'after' && lastShouldIncrement && lastWillAddMore)\n    ) {\n      if (firstWillAddMore) {\n        newCellCount++;\n      }\n      first--;\n    }\n    if (\n      lastShouldIncrement &&\n      !(fillPreference === 'before' && firstShouldIncrement && firstWillAddMore)\n    ) {\n      if (lastWillAddMore) {\n        newCellCount++;\n      }\n      last++;\n    }\n  }\n  if (\n    !(\n      last >= first &&\n      first >= 0 &&\n      last < itemCount &&\n      first >= overscanFirst &&\n      last <= overscanLast &&\n      first <= visible.first &&\n      last >= visible.last\n    )\n  ) {\n    throw new Error(\n      'Bad window calculation ' +\n        JSON.stringify({\n          first,\n          last,\n          itemCount,\n          overscanFirst,\n          overscanLast,\n          visible,\n        }),\n    );\n  }\n  return {first, last};\n}\n\nexport function keyExtractor(item: any, index: number): string {\n  if (typeof item === 'object' && item?.key != null) {\n    return item.key;\n  }\n  if (typeof item === 'object' && item?.id != null) {\n    return item.id;\n  }\n  return String(index);\n}\n"]}