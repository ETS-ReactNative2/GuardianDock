{"version":3,"mappings":"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","names":["getActiveRoute","state","route","index","routes","length","getPathFromState","options","Error","configs","screens","createNormalizedConfigs","path","current","allParams","pattern","focusedParams","focusedRoute","currentOptions","nestedRouteNames","hasNext","name","push","params","stringify","_currentOptions$route","currentParams","Object","entries","map","key","value","String","split","filter","p","startsWith","forEach","getParamName","undefined","nextRoute","nestedConfig","join","endsWith","encodeURIComponent","param","query","queryString","sort","_pattern","replace","joinPaths","paths","arguments","concat","Boolean","createConfigItem","config","parentPattern","exact","_pattern2","c","result"],"sources":["getPathFromState.tsx"],"sourcesContent":["import type {\n  NavigationState,\n  PartialState,\n  Route,\n} from '@react-navigation/routers';\nimport * as queryString from 'query-string';\n\nimport fromEntries from './fromEntries';\nimport type { PathConfig, PathConfigMap } from './types';\nimport validatePathConfig from './validatePathConfig';\n\ntype Options<ParamList> = {\n  initialRouteName?: string;\n  screens: PathConfigMap<ParamList>;\n};\n\ntype State = NavigationState | Omit<PartialState<NavigationState>, 'stale'>;\n\ntype StringifyConfig = Record<string, (value: any) => string>;\n\ntype ConfigItem = {\n  pattern?: string;\n  stringify?: StringifyConfig;\n  screens?: Record<string, ConfigItem>;\n};\n\nconst getActiveRoute = (state: State): { name: string; params?: object } => {\n  const route =\n    typeof state.index === 'number'\n      ? state.routes[state.index]\n      : state.routes[state.routes.length - 1];\n\n  if (route.state) {\n    return getActiveRoute(route.state);\n  }\n\n  return route;\n};\n\n/**\n * Utility to serialize a navigation state object to a path string.\n *\n * @example\n * ```js\n * getPathFromState(\n *   {\n *     routes: [\n *       {\n *         name: 'Chat',\n *         params: { author: 'Jane', id: 42 },\n *       },\n *     ],\n *   },\n *   {\n *     screens: {\n *       Chat: {\n *         path: 'chat/:author/:id',\n *         stringify: { author: author => author.toLowerCase() }\n *       }\n *     }\n *   }\n * )\n * ```\n *\n * @param state Navigation state to serialize.\n * @param options Extra options to fine-tune how to serialize the path.\n * @returns Path representing the state, e.g. /foo/bar?count=42.\n */\nexport default function getPathFromState<ParamList extends {}>(\n  state: State,\n  options?: Options<ParamList>\n): string {\n  if (state == null) {\n    throw Error(\n      \"Got 'undefined' for the navigation state. You must pass a valid state object.\"\n    );\n  }\n\n  if (options) {\n    validatePathConfig(options);\n  }\n\n  // Create a normalized configs object which will be easier to use\n  const configs: Record<string, ConfigItem> = options?.screens\n    ? createNormalizedConfigs(options?.screens)\n    : {};\n\n  let path = '/';\n  let current: State | undefined = state;\n\n  const allParams: Record<string, any> = {};\n\n  while (current) {\n    let index = typeof current.index === 'number' ? current.index : 0;\n    let route = current.routes[index] as Route<string> & {\n      state?: State;\n    };\n\n    let pattern: string | undefined;\n\n    let focusedParams: Record<string, any> | undefined;\n    let focusedRoute = getActiveRoute(state);\n    let currentOptions = configs;\n\n    // Keep all the route names that appeared during going deeper in config in case the pattern is resolved to undefined\n    let nestedRouteNames = [];\n\n    let hasNext = true;\n\n    while (route.name in currentOptions && hasNext) {\n      pattern = currentOptions[route.name].pattern;\n\n      nestedRouteNames.push(route.name);\n\n      if (route.params) {\n        const stringify = currentOptions[route.name]?.stringify;\n\n        const currentParams = fromEntries(\n          Object.entries(route.params).map(([key, value]) => [\n            key,\n            stringify?.[key] ? stringify[key](value) : String(value),\n          ])\n        );\n\n        if (pattern) {\n          Object.assign(allParams, currentParams);\n        }\n\n        if (focusedRoute === route) {\n          // If this is the focused route, keep the params for later use\n          // We save it here since it's been stringified already\n          focusedParams = { ...currentParams };\n\n          pattern\n            ?.split('/')\n            .filter((p) => p.startsWith(':'))\n            // eslint-disable-next-line no-loop-func\n            .forEach((p) => {\n              const name = getParamName(p);\n\n              // Remove the params present in the pattern since we'll only use the rest for query string\n              if (focusedParams) {\n                // eslint-disable-next-line @typescript-eslint/no-dynamic-delete\n                delete focusedParams[name];\n              }\n            });\n        }\n      }\n\n      // If there is no `screens` property or no nested state, we return pattern\n      if (!currentOptions[route.name].screens || route.state === undefined) {\n        hasNext = false;\n      } else {\n        index =\n          typeof route.state.index === 'number'\n            ? route.state.index\n            : route.state.routes.length - 1;\n\n        const nextRoute = route.state.routes[index];\n        const nestedConfig = currentOptions[route.name].screens;\n\n        // if there is config for next route name, we go deeper\n        if (nestedConfig && nextRoute.name in nestedConfig) {\n          route = nextRoute as Route<string> & { state?: State };\n          currentOptions = nestedConfig;\n        } else {\n          // If not, there is no sense in going deeper in config\n          hasNext = false;\n        }\n      }\n    }\n\n    if (pattern === undefined) {\n      pattern = nestedRouteNames.join('/');\n    }\n\n    if (currentOptions[route.name] !== undefined) {\n      path += pattern\n        .split('/')\n        .map((p) => {\n          const name = getParamName(p);\n\n          // We don't know what to show for wildcard patterns\n          // Showing the route name seems ok, though whatever we show here will be incorrect\n          // Since the page doesn't actually exist\n          if (p === '*') {\n            return route.name;\n          }\n\n          // If the path has a pattern for a param, put the param in the path\n          if (p.startsWith(':')) {\n            const value = allParams[name];\n\n            if (value === undefined && p.endsWith('?')) {\n              // Optional params without value assigned in route.params should be ignored\n              return '';\n            }\n\n            return encodeURIComponent(value);\n          }\n\n          return encodeURIComponent(p);\n        })\n        .join('/');\n    } else {\n      path += encodeURIComponent(route.name);\n    }\n\n    if (!focusedParams) {\n      focusedParams = focusedRoute.params;\n    }\n\n    if (route.state) {\n      path += '/';\n    } else if (focusedParams) {\n      for (let param in focusedParams) {\n        if (focusedParams[param] === 'undefined') {\n          // eslint-disable-next-line @typescript-eslint/no-dynamic-delete\n          delete focusedParams[param];\n        }\n      }\n\n      const query = queryString.stringify(focusedParams, { sort: false });\n\n      if (query) {\n        path += `?${query}`;\n      }\n    }\n\n    current = route.state;\n  }\n\n  // Remove multiple as well as trailing slashes\n  path = path.replace(/\\/+/g, '/');\n  path = path.length > 1 ? path.replace(/\\/$/, '') : path;\n\n  return path;\n}\n\nconst getParamName = (pattern: string) =>\n  pattern.replace(/^:/, '').replace(/\\?$/, '');\n\nconst joinPaths = (...paths: string[]): string =>\n  ([] as string[])\n    .concat(...paths.map((p) => p.split('/')))\n    .filter(Boolean)\n    .join('/');\n\nconst createConfigItem = (\n  config: PathConfig<object> | string,\n  parentPattern?: string\n): ConfigItem => {\n  if (typeof config === 'string') {\n    // If a string is specified as the value of the key(e.g. Foo: '/path'), use it as the pattern\n    const pattern = parentPattern ? joinPaths(parentPattern, config) : config;\n\n    return { pattern };\n  }\n\n  // If an object is specified as the value (e.g. Foo: { ... }),\n  // It can have `path` property and `screens` prop which has nested configs\n  let pattern: string | undefined;\n\n  if (config.exact && config.path === undefined) {\n    throw new Error(\n      \"A 'path' needs to be specified when specifying 'exact: true'. If you don't want this screen in the URL, specify it as empty string, e.g. `path: ''`.\"\n    );\n  }\n\n  pattern =\n    config.exact !== true\n      ? joinPaths(parentPattern || '', config.path || '')\n      : config.path || '';\n\n  const screens = config.screens\n    ? createNormalizedConfigs(config.screens, pattern)\n    : undefined;\n\n  return {\n    // Normalize pattern to remove any leading, trailing slashes, duplicate slashes etc.\n    pattern: pattern?.split('/').filter(Boolean).join('/'),\n    stringify: config.stringify,\n    screens,\n  };\n};\n\nconst createNormalizedConfigs = (\n  options: PathConfigMap<object>,\n  pattern?: string\n): Record<string, ConfigItem> =>\n  fromEntries(\n    Object.entries(options).map(([name, c]) => {\n      const result = createConfigItem(c, pattern);\n\n      return [name, result];\n    })\n  );\n"]}