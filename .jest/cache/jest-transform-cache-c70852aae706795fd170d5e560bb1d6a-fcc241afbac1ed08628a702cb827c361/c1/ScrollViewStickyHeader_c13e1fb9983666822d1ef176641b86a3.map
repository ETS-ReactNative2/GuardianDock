{"version":3,"sources":["ScrollViewStickyHeader.js"],"names":["AnimatedView","AnimatedImplementation","createAnimatedComponent","View","ScrollViewStickyHeader","state","measured","layoutY","layoutHeight","nextHeaderLayoutY","props","translateY","_translateY","_shouldRecreateTranslateY","_haveReceivedInitialZeroTranslateY","_debounceTimeout","Platform","OS","setNextHeaderY","y","setState","_onLayout","event","nativeEvent","layout","height","onLayout","child","React","Children","only","children","_setComponentRef","ref","_ref","_animatedValueListenerId","removeListener","_timer","clearTimeout","nextProps","scrollViewHeight","scrollAnimatedValue","inverted","isFabric","offset","AnimatedAddition","_animatedValueListener","value","setTimeout","addListener","stateNode","canonical","inputRange","outputRange","stickStartPoint","push","collisionPoint","updateTranslateListener","interpolate","hiddenOnScroll","AnimatedDiffClamp","extrapolateLeft","passthroughAnimatedPropExplicitValues","style","transform","nativeID","styles","header","cloneElement","fill","undefined","Component","StyleSheet","create","zIndex","position","flex","module","exports"],"mappings":"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","sourcesContent":["/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @flow\n * @format\n */\n\nimport AnimatedImplementation from '../../Animated/AnimatedImplementation';\nimport AnimatedAddition from '../../Animated/nodes/AnimatedAddition';\nimport AnimatedDiffClamp from '../../Animated/nodes/AnimatedDiffClamp';\nimport AnimatedNode from '../../Animated/nodes/AnimatedNode';\n\nimport * as React from 'react';\nimport StyleSheet from '../../StyleSheet/StyleSheet';\nimport View from '../View/View';\nimport Platform from '../../Utilities/Platform';\n\nimport type {LayoutEvent} from '../../Types/CoreEventTypes';\n\nconst AnimatedView = AnimatedImplementation.createAnimatedComponent(View);\n\nexport type Props = $ReadOnly<{\n  children?: React.Element<any>,\n  nextHeaderLayoutY: ?number,\n  onLayout: (event: LayoutEvent) => void,\n  scrollAnimatedValue: AnimatedImplementation.Value,\n  // Will cause sticky headers to stick at the bottom of the ScrollView instead\n  // of the top.\n  inverted: ?boolean,\n  // The height of the parent ScrollView. Currently only set when inverted.\n  scrollViewHeight: ?number,\n  nativeID?: ?string,\n  hiddenOnScroll?: ?boolean,\n}>;\n\ntype State = {\n  measured: boolean,\n  layoutY: number,\n  layoutHeight: number,\n  nextHeaderLayoutY: ?number,\n  translateY: ?number,\n  ...\n};\n\nclass ScrollViewStickyHeader extends React.Component<Props, State> {\n  state: State = {\n    measured: false,\n    layoutY: 0,\n    layoutHeight: 0,\n    nextHeaderLayoutY: this.props.nextHeaderLayoutY,\n    translateY: null,\n  };\n\n  _translateY: ?AnimatedNode = null;\n  _shouldRecreateTranslateY: boolean = true;\n  _haveReceivedInitialZeroTranslateY: boolean = true;\n  _ref: any; // TODO T53738161: flow type this, and the whole file\n\n  // Fabric-only:\n  _timer: ?TimeoutID;\n  _animatedValueListenerId: string;\n  _animatedValueListener: (valueObject: $ReadOnly<{|value: number|}>) => void;\n  _debounceTimeout: number = Platform.OS === 'android' ? 15 : 64;\n\n  setNextHeaderY: (y: number) => void = (y: number): void => {\n    this._shouldRecreateTranslateY = true;\n    this.setState({nextHeaderLayoutY: y});\n  };\n\n  componentWillUnmount() {\n    if (this._translateY != null && this._animatedValueListenerId != null) {\n      this._translateY.removeListener(this._animatedValueListenerId);\n    }\n    if (this._timer) {\n      clearTimeout(this._timer);\n    }\n  }\n\n  UNSAFE_componentWillReceiveProps(nextProps: Props) {\n    if (\n      nextProps.scrollViewHeight !== this.props.scrollViewHeight ||\n      nextProps.scrollAnimatedValue !== this.props.scrollAnimatedValue ||\n      nextProps.inverted !== this.props.inverted\n    ) {\n      this._shouldRecreateTranslateY = true;\n    }\n  }\n\n  updateTranslateListener(\n    translateY: AnimatedImplementation.Interpolation,\n    isFabric: boolean,\n    offset: AnimatedDiffClamp | null,\n  ) {\n    if (this._translateY != null && this._animatedValueListenerId != null) {\n      this._translateY.removeListener(this._animatedValueListenerId);\n    }\n    offset\n      ? (this._translateY = new AnimatedAddition(translateY, offset))\n      : (this._translateY = translateY);\n\n    this._shouldRecreateTranslateY = false;\n\n    if (!isFabric) {\n      return;\n    }\n\n    if (!this._animatedValueListener) {\n      // This is called whenever the (Interpolated) Animated Value\n      // updates, which is several times per frame during scrolling.\n      // To ensure that the Fabric ShadowTree has the most recent\n      // translate style of this node, we debounce the value and then\n      // pass it through to the underlying node during render.\n      // This is:\n      // 1. Only an issue in Fabric.\n      // 2. Worse in Android than iOS. In Android, but not iOS, you\n      //    can touch and move your finger slightly and still trigger\n      //    a \"tap\" event. In iOS, moving will cancel the tap in\n      //    both Fabric and non-Fabric. On Android when you move\n      //    your finger, the hit-detection moves from the Android\n      //    platform to JS, so we need the ShadowTree to have knowledge\n      //    of the current position.\n      this._animatedValueListener = ({value}) => {\n        // When the AnimatedInterpolation is recreated, it always initializes\n        // to a value of zero and emits a value change of 0 to its listeners.\n        if (value === 0 && !this._haveReceivedInitialZeroTranslateY) {\n          this._haveReceivedInitialZeroTranslateY = true;\n          return;\n        }\n        if (this._timer) {\n          clearTimeout(this._timer);\n        }\n        this._timer = setTimeout(() => {\n          if (value !== this.state.translateY) {\n            this.setState({\n              translateY: value,\n            });\n          }\n        }, this._debounceTimeout);\n      };\n    }\n    if (this.state.translateY !== 0 && this.state.translateY != null) {\n      this._haveReceivedInitialZeroTranslateY = false;\n    }\n    this._animatedValueListenerId = translateY.addListener(\n      this._animatedValueListener,\n    );\n  }\n\n  _onLayout = event => {\n    const layoutY = event.nativeEvent.layout.y;\n    const layoutHeight = event.nativeEvent.layout.height;\n    const measured = true;\n\n    if (\n      layoutY !== this.state.layoutY ||\n      layoutHeight !== this.state.layoutHeight ||\n      measured !== this.state.measured\n    ) {\n      this._shouldRecreateTranslateY = true;\n    }\n\n    this.setState({\n      measured,\n      layoutY,\n      layoutHeight,\n    });\n\n    this.props.onLayout(event);\n    const child = React.Children.only(this.props.children);\n    if (child.props.onLayout) {\n      child.props.onLayout(event);\n    }\n  };\n\n  _setComponentRef = ref => {\n    this._ref = ref;\n  };\n\n  render(): React.Node {\n    // Fabric Detection\n    const isFabric = !!(\n      // An internal transform mangles variables with leading \"_\" as private.\n      // eslint-disable-next-line dot-notation\n      (this._ref && this._ref['_internalInstanceHandle']?.stateNode?.canonical)\n    );\n    // Initially and in the case of updated props or layout, we\n    // recreate this interpolated value. Otherwise, we do not recreate\n    // when there are state changes.\n    if (this._shouldRecreateTranslateY) {\n      const {inverted, scrollViewHeight} = this.props;\n      const {measured, layoutHeight, layoutY, nextHeaderLayoutY} = this.state;\n      const inputRange: Array<number> = [-1, 0];\n      const outputRange: Array<number> = [0, 0];\n\n      if (measured) {\n        if (inverted) {\n          // The interpolation looks like:\n          // - Negative scroll: no translation\n          // - `stickStartPoint` is the point at which the header will start sticking.\n          //   It is calculated using the ScrollView viewport height so it is a the bottom.\n          // - Headers that are in the initial viewport will never stick, `stickStartPoint`\n          //   will be negative.\n          // - From 0 to `stickStartPoint` no translation. This will cause the header\n          //   to scroll normally until it reaches the top of the scroll view.\n          // - From `stickStartPoint` to when the next header y hits the bottom edge of the header: translate\n          //   equally to scroll. This will cause the header to stay at the top of the scroll view.\n          // - Past the collision with the next header y: no more translation. This will cause the\n          //   header to continue scrolling up and make room for the next sticky header.\n          //   In the case that there is no next header just translate equally to\n          //   scroll indefinitely.\n          if (scrollViewHeight != null) {\n            const stickStartPoint = layoutY + layoutHeight - scrollViewHeight;\n            if (stickStartPoint > 0) {\n              inputRange.push(stickStartPoint);\n              outputRange.push(0);\n              inputRange.push(stickStartPoint + 1);\n              outputRange.push(1);\n              // If the next sticky header has not loaded yet (probably windowing) or is the last\n              // we can just keep it sticked forever.\n              const collisionPoint =\n                (nextHeaderLayoutY || 0) - layoutHeight - scrollViewHeight;\n              if (collisionPoint > stickStartPoint) {\n                inputRange.push(collisionPoint, collisionPoint + 1);\n                outputRange.push(\n                  collisionPoint - stickStartPoint,\n                  collisionPoint - stickStartPoint,\n                );\n              }\n            }\n          }\n        } else {\n          // The interpolation looks like:\n          // - Negative scroll: no translation\n          // - From 0 to the y of the header: no translation. This will cause the header\n          //   to scroll normally until it reaches the top of the scroll view.\n          // - From header y to when the next header y hits the bottom edge of the header: translate\n          //   equally to scroll. This will cause the header to stay at the top of the scroll view.\n          // - Past the collision with the next header y: no more translation. This will cause the\n          //   header to continue scrolling up and make room for the next sticky header.\n          //   In the case that there is no next header just translate equally to\n          //   scroll indefinitely.\n          inputRange.push(layoutY);\n          outputRange.push(0);\n          // If the next sticky header has not loaded yet (probably windowing) or is the last\n          // we can just keep it sticked forever.\n          const collisionPoint = (nextHeaderLayoutY || 0) - layoutHeight;\n          if (collisionPoint >= layoutY) {\n            inputRange.push(collisionPoint, collisionPoint + 1);\n            outputRange.push(\n              collisionPoint - layoutY,\n              collisionPoint - layoutY,\n            );\n          } else {\n            inputRange.push(layoutY + 1);\n            outputRange.push(1);\n          }\n        }\n      }\n\n      this.updateTranslateListener(\n        this.props.scrollAnimatedValue.interpolate({\n          inputRange,\n          outputRange,\n        }),\n        isFabric,\n        this.props.hiddenOnScroll\n          ? new AnimatedDiffClamp(\n              this.props.scrollAnimatedValue\n                .interpolate({\n                  extrapolateLeft: 'clamp',\n                  inputRange: [layoutY, layoutY + 1],\n                  outputRange: ([0, 1]: Array<number>),\n                })\n                .interpolate({\n                  inputRange: [0, 1],\n                  outputRange: ([0, -1]: Array<number>),\n                }),\n              -this.state.layoutHeight,\n              0,\n            )\n          : null,\n      );\n    }\n\n    const child = React.Children.only(this.props.children);\n\n    // TODO T68319535: remove this if NativeAnimated is rewritten for Fabric\n    const passthroughAnimatedPropExplicitValues =\n      isFabric && this.state.translateY != null\n        ? {\n            style: {transform: [{translateY: this.state.translateY}]},\n          }\n        : null;\n\n    return (\n      <AnimatedView\n        collapsable={false}\n        nativeID={this.props.nativeID}\n        onLayout={this._onLayout}\n        ref={this._setComponentRef}\n        style={[\n          child.props.style,\n          styles.header,\n          {transform: [{translateY: this._translateY}]},\n        ]}\n        passthroughAnimatedPropExplicitValues={\n          passthroughAnimatedPropExplicitValues\n        }>\n        {React.cloneElement(child, {\n          style: styles.fill, // We transfer the child style to the wrapper.\n          onLayout: undefined, // we call this manually through our this._onLayout\n        })}\n      </AnimatedView>\n    );\n  }\n}\n\nconst styles = StyleSheet.create({\n  header: {\n    zIndex: 10,\n    position: 'relative',\n  },\n  fill: {\n    flex: 1,\n  },\n});\n\nmodule.exports = ScrollViewStickyHeader;\n"]}