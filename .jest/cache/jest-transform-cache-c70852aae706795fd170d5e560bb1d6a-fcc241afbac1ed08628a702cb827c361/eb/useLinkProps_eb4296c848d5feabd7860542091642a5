a2ea68d9c73073b217c73d4153b75a6b
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = useLinkProps;

var _core = require("@react-navigation/core");

var React = _interopRequireWildcard(require("react"));

var _reactNative = require("react-native");

var _LinkingContext = _interopRequireDefault(require("./LinkingContext"));

var _useLinkTo = _interopRequireDefault(require("./useLinkTo"));

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}

function _getRequireWildcardCache(nodeInterop) {
  if (typeof WeakMap !== "function") return null;
  var cacheBabelInterop = new WeakMap();
  var cacheNodeInterop = new WeakMap();
  return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) {
    return nodeInterop ? cacheNodeInterop : cacheBabelInterop;
  })(nodeInterop);
}

function _interopRequireWildcard(obj, nodeInterop) {
  if (!nodeInterop && obj && obj.__esModule) {
    return obj;
  }

  if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
    return {
      default: obj
    };
  }

  var cache = _getRequireWildcardCache(nodeInterop);

  if (cache && cache.has(obj)) {
    return cache.get(obj);
  }

  var newObj = {};
  var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;

  for (var key in obj) {
    if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
      var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;

      if (desc && (desc.get || desc.set)) {
        Object.defineProperty(newObj, key, desc);
      } else {
        newObj[key] = obj[key];
      }
    }
  }

  newObj.default = obj;

  if (cache) {
    cache.set(obj, newObj);
  }

  return newObj;
}

var getStateFromParams = function getStateFromParams(params) {
  if (params !== null && params !== void 0 && params.state) {
    return params.state;
  }

  if (params !== null && params !== void 0 && params.screen) {
    return {
      routes: [{
        name: params.screen,
        params: params.params,
        state: params.screen ? getStateFromParams(params.params) : undefined
      }]
    };
  }

  return undefined;
};

function useLinkProps(_ref) {
  var _options$getPathFromS;

  var to = _ref.to,
      action = _ref.action;
  var root = React.useContext(_core.NavigationContainerRefContext);
  var navigation = React.useContext(_core.NavigationHelpersContext);

  var _React$useContext = React.useContext(_LinkingContext.default),
      options = _React$useContext.options;

  var linkTo = (0, _useLinkTo.default)();

  var onPress = function onPress(e) {
    var _e$currentTarget;

    var shouldHandle = false;

    if (_reactNative.Platform.OS !== 'web' || !e) {
      shouldHandle = e ? !e.defaultPrevented : true;
    } else if (!e.defaultPrevented && !(e.metaKey || e.altKey || e.ctrlKey || e.shiftKey) && (e.button == null || e.button === 0) && [undefined, null, '', 'self'].includes((_e$currentTarget = e.currentTarget) === null || _e$currentTarget === void 0 ? void 0 : _e$currentTarget.target)) {
      e.preventDefault();
      shouldHandle = true;
    }

    if (shouldHandle) {
      if (action) {
        if (navigation) {
          navigation.dispatch(action);
        } else if (root) {
          root.dispatch(action);
        } else {
          throw new Error("Couldn't find a navigation object. Is your component inside NavigationContainer?");
        }
      } else {
        linkTo(to);
      }
    }
  };

  var getPathFromStateHelper = (_options$getPathFromS = options === null || options === void 0 ? void 0 : options.getPathFromState) !== null && _options$getPathFromS !== void 0 ? _options$getPathFromS : _core.getPathFromState;
  var href = typeof to === 'string' ? to : getPathFromStateHelper({
    routes: [{
      name: to.screen,
      params: to.params,
      state: getStateFromParams(to.params)
    }]
  }, options === null || options === void 0 ? void 0 : options.config);
  return {
    href: href,
    accessibilityRole: 'link',
    onPress: onPress
  };
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QUVxQixnQkFBWix5RUFBZ0NBLHNCQUE1RDtBQUVBLE1BQU1DLElBQUksR0FDUixPQUFPL0IsRUFBUCxLQUFjLFFBQWQsR0FDSUEsRUFESixHQUVJNkIsc0JBQXNCLENBQ3BCO0FBQ0VqQyxVQUFNLEVBQUUsQ0FDTjtBQUNFQyxVQUFJLEVBQUVHLEVBQUUsQ0FBQ0wsTUFEWDtBQUdFRixZQUFNLEVBQUVPLEVBQUUsQ0FBQ1AsTUFIYjtBQUtFQyxXQUFLLEVBQUVGLGtCQUFrQixDQUFDUSxFQUFFLENBQUNQLE1BQUo7QUFMM0IsS0FETTtBQURWLEdBRG9CLEVBWXBCZ0IsT0Fab0IsU0FZcEJBLFdBWm9CLFdBWXBCQSxHQVpvQixNQVlwQkEsVUFBTyxDQUFFdUIsTUFaVyxDQUg1QjtBQWtCQSxTQUFPO0FBQ0xELFFBREssRUFDTEEsSUFESztBQUVMRSxxQkFBaUIsRUFBRSxNQUZkO0FBR0x0QjtBQUhLLEdBQVA7QUFLRCIsIm5hbWVzIjpbImdldFN0YXRlRnJvbVBhcmFtcyIsInBhcmFtcyIsInN0YXRlIiwic2NyZWVuIiwicm91dGVzIiwibmFtZSIsInVuZGVmaW5lZCIsInVzZUxpbmtQcm9wcyIsInRvIiwiYWN0aW9uIiwicm9vdCIsIlJlYWN0IiwidXNlQ29udGV4dCIsIk5hdmlnYXRpb25Db250YWluZXJSZWZDb250ZXh0IiwibmF2aWdhdGlvbiIsIk5hdmlnYXRpb25IZWxwZXJzQ29udGV4dCIsIkxpbmtpbmdDb250ZXh0Iiwib3B0aW9ucyIsImxpbmtUbyIsIm9uUHJlc3MiLCJlIiwic2hvdWxkSGFuZGxlIiwiUGxhdGZvcm0iLCJPUyIsImRlZmF1bHRQcmV2ZW50ZWQiLCJtZXRhS2V5IiwiYWx0S2V5IiwiY3RybEtleSIsInNoaWZ0S2V5IiwiYnV0dG9uIiwiaW5jbHVkZXMiLCJjdXJyZW50VGFyZ2V0IiwiX2UkY3VycmVudFRhcmdldCIsInRhcmdldCIsInByZXZlbnREZWZhdWx0IiwiZGlzcGF0Y2giLCJFcnJvciIsImdldFBhdGhGcm9tU3RhdGVIZWxwZXIiLCJnZXRQYXRoRnJvbVN0YXRlIiwiaHJlZiIsImNvbmZpZyIsImFjY2Vzc2liaWxpdHlSb2xlIl0sInNvdXJjZXMiOlsidXNlTGlua1Byb3BzLnRzeCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge1xuICBnZXRQYXRoRnJvbVN0YXRlLFxuICBOYXZpZ2F0aW9uQWN0aW9uLFxuICBOYXZpZ2F0aW9uQ29udGFpbmVyUmVmQ29udGV4dCxcbiAgTmF2aWdhdGlvbkhlbHBlcnNDb250ZXh0LFxuICBOYXZpZ2F0b3JTY3JlZW5QYXJhbXMsXG4gIFBhcmFtTGlzdEJhc2UsXG59IGZyb20gJ0ByZWFjdC1uYXZpZ2F0aW9uL2NvcmUnO1xuaW1wb3J0IHR5cGUgeyBOYXZpZ2F0aW9uU3RhdGUsIFBhcnRpYWxTdGF0ZSB9IGZyb20gJ0ByZWFjdC1uYXZpZ2F0aW9uL3JvdXRlcnMnO1xuaW1wb3J0ICogYXMgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgR2VzdHVyZVJlc3BvbmRlckV2ZW50LCBQbGF0Zm9ybSB9IGZyb20gJ3JlYWN0LW5hdGl2ZSc7XG5cbmltcG9ydCBMaW5raW5nQ29udGV4dCBmcm9tICcuL0xpbmtpbmdDb250ZXh0JztcbmltcG9ydCB1c2VMaW5rVG8sIHsgVG8gfSBmcm9tICcuL3VzZUxpbmtUbyc7XG5cbnR5cGUgUHJvcHM8UGFyYW1MaXN0IGV4dGVuZHMgUmVhY3ROYXZpZ2F0aW9uLlJvb3RQYXJhbUxpc3Q+ID0ge1xuICB0bzogVG88UGFyYW1MaXN0PjtcbiAgYWN0aW9uPzogTmF2aWdhdGlvbkFjdGlvbjtcbn07XG5cbmNvbnN0IGdldFN0YXRlRnJvbVBhcmFtcyA9IChcbiAgcGFyYW1zOiBOYXZpZ2F0b3JTY3JlZW5QYXJhbXM8UGFyYW1MaXN0QmFzZSwgTmF2aWdhdGlvblN0YXRlPiB8IHVuZGVmaW5lZFxuKTogUGFydGlhbFN0YXRlPE5hdmlnYXRpb25TdGF0ZT4gfCBOYXZpZ2F0aW9uU3RhdGUgfCB1bmRlZmluZWQgPT4ge1xuICBpZiAocGFyYW1zPy5zdGF0ZSkge1xuICAgIHJldHVybiBwYXJhbXMuc3RhdGU7XG4gIH1cblxuICBpZiAocGFyYW1zPy5zY3JlZW4pIHtcbiAgICByZXR1cm4ge1xuICAgICAgcm91dGVzOiBbXG4gICAgICAgIHtcbiAgICAgICAgICBuYW1lOiBwYXJhbXMuc2NyZWVuLFxuICAgICAgICAgIHBhcmFtczogcGFyYW1zLnBhcmFtcyxcbiAgICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yXG4gICAgICAgICAgc3RhdGU6IHBhcmFtcy5zY3JlZW5cbiAgICAgICAgICAgID8gZ2V0U3RhdGVGcm9tUGFyYW1zKFxuICAgICAgICAgICAgICAgIHBhcmFtcy5wYXJhbXMgYXNcbiAgICAgICAgICAgICAgICAgIHwgTmF2aWdhdG9yU2NyZWVuUGFyYW1zPFBhcmFtTGlzdEJhc2UsIE5hdmlnYXRpb25TdGF0ZT5cbiAgICAgICAgICAgICAgICAgIHwgdW5kZWZpbmVkXG4gICAgICAgICAgICAgIClcbiAgICAgICAgICAgIDogdW5kZWZpbmVkLFxuICAgICAgICB9LFxuICAgICAgXSxcbiAgICB9O1xuICB9XG5cbiAgcmV0dXJuIHVuZGVmaW5lZDtcbn07XG5cbi8qKlxuICogSG9vayB0byBnZXQgcHJvcHMgZm9yIGFuIGFuY2hvciB0YWcgc28gaXQgY2FuIHdvcmsgd2l0aCBpbiBwYWdlIG5hdmlnYXRpb24uXG4gKlxuICogQHBhcmFtIHByb3BzLnRvIEFic29sdXRlIHBhdGggdG8gc2NyZWVuIChlLmcuIGAvZmVlZHMvaG90YCkuXG4gKiBAcGFyYW0gcHJvcHMuYWN0aW9uIE9wdGlvbmFsIGFjdGlvbiB0byB1c2UgZm9yIGluLXBhZ2UgbmF2aWdhdGlvbi4gQnkgZGVmYXVsdCwgdGhlIHBhdGggaXMgcGFyc2VkIHRvIGFuIGFjdGlvbiBiYXNlZCBvbiBsaW5raW5nIGNvbmZpZy5cbiAqL1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gdXNlTGlua1Byb3BzPFxuICBQYXJhbUxpc3QgZXh0ZW5kcyBSZWFjdE5hdmlnYXRpb24uUm9vdFBhcmFtTGlzdFxuPih7IHRvLCBhY3Rpb24gfTogUHJvcHM8UGFyYW1MaXN0Pikge1xuICBjb25zdCByb290ID0gUmVhY3QudXNlQ29udGV4dChOYXZpZ2F0aW9uQ29udGFpbmVyUmVmQ29udGV4dCk7XG4gIGNvbnN0IG5hdmlnYXRpb24gPSBSZWFjdC51c2VDb250ZXh0KE5hdmlnYXRpb25IZWxwZXJzQ29udGV4dCk7XG4gIGNvbnN0IHsgb3B0aW9ucyB9ID0gUmVhY3QudXNlQ29udGV4dChMaW5raW5nQ29udGV4dCk7XG4gIGNvbnN0IGxpbmtUbyA9IHVzZUxpbmtUbzxQYXJhbUxpc3Q+KCk7XG5cbiAgY29uc3Qgb25QcmVzcyA9IChcbiAgICBlPzogUmVhY3QuTW91c2VFdmVudDxIVE1MQW5jaG9yRWxlbWVudCwgTW91c2VFdmVudD4gfCBHZXN0dXJlUmVzcG9uZGVyRXZlbnRcbiAgKSA9PiB7XG4gICAgbGV0IHNob3VsZEhhbmRsZSA9IGZhbHNlO1xuXG4gICAgaWYgKFBsYXRmb3JtLk9TICE9PSAnd2ViJyB8fCAhZSkge1xuICAgICAgc2hvdWxkSGFuZGxlID0gZSA/ICFlLmRlZmF1bHRQcmV2ZW50ZWQgOiB0cnVlO1xuICAgIH0gZWxzZSBpZiAoXG4gICAgICAhZS5kZWZhdWx0UHJldmVudGVkICYmIC8vIG9uUHJlc3MgcHJldmVudGVkIGRlZmF1bHRcbiAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3I6IHRoZXNlIHByb3BlcnRpZXMgZXhpc3Qgb24gd2ViLCBidXQgbm90IGluIFJlYWN0IE5hdGl2ZVxuICAgICAgIShlLm1ldGFLZXkgfHwgZS5hbHRLZXkgfHwgZS5jdHJsS2V5IHx8IGUuc2hpZnRLZXkpICYmIC8vIGlnbm9yZSBjbGlja3Mgd2l0aCBtb2RpZmllciBrZXlzXG4gICAgICAvLyBAdHMtZXhwZWN0LWVycm9yOiB0aGVzZSBwcm9wZXJ0aWVzIGV4aXN0IG9uIHdlYiwgYnV0IG5vdCBpbiBSZWFjdCBOYXRpdmVcbiAgICAgIChlLmJ1dHRvbiA9PSBudWxsIHx8IGUuYnV0dG9uID09PSAwKSAmJiAvLyBpZ25vcmUgZXZlcnl0aGluZyBidXQgbGVmdCBjbGlja3NcbiAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3I6IHRoZXNlIHByb3BlcnRpZXMgZXhpc3Qgb24gd2ViLCBidXQgbm90IGluIFJlYWN0IE5hdGl2ZVxuICAgICAgW3VuZGVmaW5lZCwgbnVsbCwgJycsICdzZWxmJ10uaW5jbHVkZXMoZS5jdXJyZW50VGFyZ2V0Py50YXJnZXQpIC8vIGxldCBicm93c2VyIGhhbmRsZSBcInRhcmdldD1fYmxhbmtcIiBldGMuXG4gICAgKSB7XG4gICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICBzaG91bGRIYW5kbGUgPSB0cnVlO1xuICAgIH1cblxuICAgIGlmIChzaG91bGRIYW5kbGUpIHtcbiAgICAgIGlmIChhY3Rpb24pIHtcbiAgICAgICAgaWYgKG5hdmlnYXRpb24pIHtcbiAgICAgICAgICBuYXZpZ2F0aW9uLmRpc3BhdGNoKGFjdGlvbik7XG4gICAgICAgIH0gZWxzZSBpZiAocm9vdCkge1xuICAgICAgICAgIHJvb3QuZGlzcGF0Y2goYWN0aW9uKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICBcIkNvdWxkbid0IGZpbmQgYSBuYXZpZ2F0aW9uIG9iamVjdC4gSXMgeW91ciBjb21wb25lbnQgaW5zaWRlIE5hdmlnYXRpb25Db250YWluZXI/XCJcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsaW5rVG8odG8pO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICBjb25zdCBnZXRQYXRoRnJvbVN0YXRlSGVscGVyID0gb3B0aW9ucz8uZ2V0UGF0aEZyb21TdGF0ZSA/PyBnZXRQYXRoRnJvbVN0YXRlO1xuXG4gIGNvbnN0IGhyZWYgPVxuICAgIHR5cGVvZiB0byA9PT0gJ3N0cmluZydcbiAgICAgID8gdG9cbiAgICAgIDogZ2V0UGF0aEZyb21TdGF0ZUhlbHBlcihcbiAgICAgICAgICB7XG4gICAgICAgICAgICByb3V0ZXM6IFtcbiAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIG5hbWU6IHRvLnNjcmVlbixcbiAgICAgICAgICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yXG4gICAgICAgICAgICAgICAgcGFyYW1zOiB0by5wYXJhbXMsXG4gICAgICAgICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvclxuICAgICAgICAgICAgICAgIHN0YXRlOiBnZXRTdGF0ZUZyb21QYXJhbXModG8ucGFyYW1zKSxcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgfSxcbiAgICAgICAgICBvcHRpb25zPy5jb25maWdcbiAgICAgICAgKTtcblxuICByZXR1cm4ge1xuICAgIGhyZWYsXG4gICAgYWNjZXNzaWJpbGl0eVJvbGU6ICdsaW5rJyBhcyBjb25zdCxcbiAgICBvblByZXNzLFxuICB9O1xufVxuIl19