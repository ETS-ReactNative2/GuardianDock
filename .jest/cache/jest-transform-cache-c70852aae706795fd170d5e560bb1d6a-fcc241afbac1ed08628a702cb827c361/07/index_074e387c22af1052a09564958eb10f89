c2b0599e1732a6cfc502321687a110e5
'use strict';

var _interopRequireDefault2 = require("@babel/runtime/helpers/interopRequireDefault");

var _regenerator = _interopRequireDefault2(require("@babel/runtime/regenerator"));

var _inherits2 = _interopRequireDefault2(require("@babel/runtime/helpers/inherits"));

var _possibleConstructorReturn2 = _interopRequireDefault2(require("@babel/runtime/helpers/possibleConstructorReturn"));

var _getPrototypeOf2 = _interopRequireDefault2(require("@babel/runtime/helpers/getPrototypeOf"));

var _wrapNativeSuper2 = _interopRequireDefault2(require("@babel/runtime/helpers/wrapNativeSuper"));

var _slicedToArray2 = _interopRequireDefault2(require("@babel/runtime/helpers/slicedToArray"));

var _extends2 = _interopRequireDefault2(require("@babel/runtime/helpers/extends"));

var _classCallCheck2 = _interopRequireDefault2(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault2(require("@babel/runtime/helpers/createClass"));

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _createForOfIteratorHelperLoose(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (it) return (it = it.call(o)).next.bind(it); if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; return function () { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

Object.defineProperty(exports, '__esModule', {
  value: true
});
exports.default = void 0;

function _chalk() {
  var data = _interopRequireDefault(require('chalk'));

  _chalk = function _chalk() {
    return data;
  };

  return data;
}

function _emittery() {
  var data = _interopRequireDefault(require('emittery'));

  _emittery = function _emittery() {
    return data;
  };

  return data;
}

function _throat() {
  var data = _interopRequireDefault(require('throat'));

  _throat = function _throat() {
    return data;
  };

  return data;
}

function _jestUtil() {
  var data = require('jest-util');

  _jestUtil = function _jestUtil() {
    return data;
  };

  return data;
}

function _jestWorker() {
  var data = require('jest-worker');

  _jestWorker = function _jestWorker() {
    return data;
  };

  return data;
}

var _runTest = _interopRequireDefault(require("./runTest"));

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}

function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

var TEST_WORKER_PATH = require.resolve("./testWorker");

var TestRunner = function () {
  function TestRunner(globalConfig, context) {
    (0, _classCallCheck2.default)(this, TestRunner);

    _defineProperty(this, '_globalConfig', void 0);

    _defineProperty(this, '_context', void 0);

    _defineProperty(this, 'eventEmitter', new (_emittery().default)());

    _defineProperty(this, '__PRIVATE_UNSTABLE_API_supportsEventEmitters__', true);

    _defineProperty(this, 'isSerial', void 0);

    this._globalConfig = globalConfig;
    this._context = context || {};
  }

  (0, _createClass2.default)(TestRunner, [{
    key: "runTests",
    value: function runTests(tests, watcher, onStart, onResult, onFailure, options) {
      return _regenerator.default.async(function runTests$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              _context.next = 2;
              return _regenerator.default.awrap(options.serial ? this._createInBandTestRun(tests, watcher, onStart, onResult, onFailure) : this._createParallelTestRun(tests, watcher, onStart, onResult, onFailure));

            case 2:
              return _context.abrupt("return", _context.sent);

            case 3:
            case "end":
              return _context.stop();
          }
        }
      }, null, this, null, Promise);
    }
  }, {
    key: "_createInBandTestRun",
    value: function _createInBandTestRun(tests, watcher, onStart, onResult, onFailure) {
      var _this = this;

      var mutex;
      return _regenerator.default.async(function _createInBandTestRun$(_context3) {
        while (1) {
          switch (_context3.prev = _context3.next) {
            case 0:
              process.env.JEST_WORKER_ID = '1';
              mutex = (0, _throat().default)(1);
              return _context3.abrupt("return", tests.reduce(function (promise, test) {
                return mutex(function () {
                  return promise.then(function _callee() {
                    var sendMessageToJest;
                    return _regenerator.default.async(function _callee$(_context2) {
                      while (1) {
                        switch (_context2.prev = _context2.next) {
                          case 0:
                            if (!watcher.isInterrupted()) {
                              _context2.next = 2;
                              break;
                            }

                            throw new CancelRun();

                          case 2:
                            if (!onStart) {
                              _context2.next = 6;
                              break;
                            }

                            _context2.next = 5;
                            return _regenerator.default.awrap(onStart(test));

                          case 5:
                            return _context2.abrupt("return", (0, _runTest.default)(test.path, _this._globalConfig, test.context.config, test.context.resolver, _this._context, undefined));

                          case 6:
                            sendMessageToJest = function sendMessageToJest(eventName, args) {
                              return _this.eventEmitter.emit(eventName, (0, _jestUtil().deepCyclicCopy)(args, {
                                keepPrototype: false
                              }));
                            };

                            _context2.next = 9;
                            return _regenerator.default.awrap(_this.eventEmitter.emit('test-file-start', [test]));

                          case 9:
                            return _context2.abrupt("return", (0, _runTest.default)(test.path, _this._globalConfig, test.context.config, test.context.resolver, _this._context, sendMessageToJest));

                          case 10:
                          case "end":
                            return _context2.stop();
                        }
                      }
                    }, null, null, null, Promise);
                  }).then(function (result) {
                    if (onResult) {
                      return onResult(test, result);
                    }

                    return _this.eventEmitter.emit('test-file-success', [test, result]);
                  }).catch(function (err) {
                    if (onFailure) {
                      return onFailure(test, err);
                    }

                    return _this.eventEmitter.emit('test-file-failure', [test, err]);
                  });
                });
              }, Promise.resolve()));

            case 3:
            case "end":
              return _context3.stop();
          }
        }
      }, null, null, null, Promise);
    }
  }, {
    key: "_createParallelTestRun",
    value: function _createParallelTestRun(tests, watcher, onStart, onResult, onFailure) {
      var _this2 = this;

      var resolvers, _iterator, _step, test, worker, mutex, runTestInWorker, onInterrupt, runAllTests, cleanup;

      return _regenerator.default.async(function _createParallelTestRun$(_context6) {
        while (1) {
          switch (_context6.prev = _context6.next) {
            case 0:
              resolvers = new Map();

              for (_iterator = _createForOfIteratorHelperLoose(tests); !(_step = _iterator()).done;) {
                test = _step.value;

                if (!resolvers.has(test.context.config.name)) {
                  resolvers.set(test.context.config.name, {
                    config: test.context.config,
                    serializableModuleMap: test.context.moduleMap.toJSON()
                  });
                }
              }

              worker = new (_jestWorker().Worker)(TEST_WORKER_PATH, {
                exposedMethods: ['worker'],
                forkOptions: {
                  stdio: 'pipe'
                },
                maxRetries: 3,
                numWorkers: this._globalConfig.maxWorkers,
                setupArgs: [{
                  serializableResolvers: Array.from(resolvers.values())
                }]
              });
              if (worker.getStdout()) worker.getStdout().pipe(process.stdout);
              if (worker.getStderr()) worker.getStderr().pipe(process.stderr);
              mutex = (0, _throat().default)(this._globalConfig.maxWorkers);

              runTestInWorker = function runTestInWorker(test) {
                return mutex(function _callee2() {
                  var promise;
                  return _regenerator.default.async(function _callee2$(_context4) {
                    while (1) {
                      switch (_context4.prev = _context4.next) {
                        case 0:
                          if (!watcher.isInterrupted()) {
                            _context4.next = 2;
                            break;
                          }

                          return _context4.abrupt("return", Promise.reject());

                        case 2:
                          if (!onStart) {
                            _context4.next = 7;
                            break;
                          }

                          _context4.next = 5;
                          return _regenerator.default.awrap(onStart(test));

                        case 5:
                          _context4.next = 9;
                          break;

                        case 7:
                          _context4.next = 9;
                          return _regenerator.default.awrap(_this2.eventEmitter.emit('test-file-start', [test]));

                        case 9:
                          promise = worker.worker({
                            config: test.context.config,
                            context: (0, _extends2.default)({}, _this2._context, {
                              changedFiles: _this2._context.changedFiles && Array.from(_this2._context.changedFiles),
                              sourcesRelatedToTestsInChangedFiles: _this2._context.sourcesRelatedToTestsInChangedFiles && Array.from(_this2._context.sourcesRelatedToTestsInChangedFiles)
                            }),
                            globalConfig: _this2._globalConfig,
                            path: test.path
                          });

                          if (promise.UNSTABLE_onCustomMessage) {
                            promise.UNSTABLE_onCustomMessage(function (_ref) {
                              var _ref2 = (0, _slicedToArray2.default)(_ref, 2),
                                  event = _ref2[0],
                                  payload = _ref2[1];

                              _this2.eventEmitter.emit(event, payload);
                            });
                          }

                          return _context4.abrupt("return", promise);

                        case 12:
                        case "end":
                          return _context4.stop();
                      }
                    }
                  }, null, null, null, Promise);
                });
              };

              onInterrupt = new Promise(function (_, reject) {
                watcher.on('change', function (state) {
                  if (state.interrupted) {
                    reject(new CancelRun());
                  }
                });
              });
              runAllTests = Promise.all(tests.map(function (test) {
                return runTestInWorker(test).then(function (result) {
                  if (onResult) {
                    return onResult(test, result);
                  }

                  return _this2.eventEmitter.emit('test-file-success', [test, result]);
                }).catch(function (error) {
                  if (onFailure) {
                    return onFailure(test, error);
                  }

                  return _this2.eventEmitter.emit('test-file-failure', [test, error]);
                });
              }));

              cleanup = function _callee3() {
                var _await$worker$end, forceExited;

                return _regenerator.default.async(function _callee3$(_context5) {
                  while (1) {
                    switch (_context5.prev = _context5.next) {
                      case 0:
                        _context5.next = 2;
                        return _regenerator.default.awrap(worker.end());

                      case 2:
                        _await$worker$end = _context5.sent;
                        forceExited = _await$worker$end.forceExited;

                        if (forceExited) {
                          console.error(_chalk().default.yellow('A worker process has failed to exit gracefully and has been force exited. ' + 'This is likely caused by tests leaking due to improper teardown. ' + 'Try running with --detectOpenHandles to find leaks. ' + 'Active timers can also cause this, ensure that .unref() was called on them.'));
                        }

                      case 5:
                      case "end":
                        return _context5.stop();
                    }
                  }
                }, null, null, null, Promise);
              };

              return _context6.abrupt("return", Promise.race([runAllTests, onInterrupt]).then(cleanup, cleanup));

            case 11:
            case "end":
              return _context6.stop();
          }
        }
      }, null, this, null, Promise);
    }
  }, {
    key: "on",
    value: function on(eventName, listener) {
      return this.eventEmitter.on(eventName, listener);
    }
  }]);
  return TestRunner;
}();

exports.default = TestRunner;

var CancelRun = function (_Error) {
  (0, _inherits2.default)(CancelRun, _Error);

  var _super = _createSuper(CancelRun);

  function CancelRun(message) {
    var _this3;

    (0, _classCallCheck2.default)(this, CancelRun);
    _this3 = _super.call(this, message);
    _this3.name = 'CancelRun';
    return _this3;
  }

  return (0, _createClass2.default)(CancelRun);
}((0, _wrapNativeSuper2.default)(Error));
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImluZGV4LmpzIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiZGVmYXVsdCIsIl9jaGFsayIsImRhdGEiLCJfaW50ZXJvcFJlcXVpcmVEZWZhdWx0IiwicmVxdWlyZSIsIl9lbWl0dGVyeSIsIl90aHJvYXQiLCJfamVzdFV0aWwiLCJfamVzdFdvcmtlciIsIl9ydW5UZXN0Iiwib2JqIiwiX19lc01vZHVsZSIsIl9kZWZpbmVQcm9wZXJ0eSIsImtleSIsImVudW1lcmFibGUiLCJjb25maWd1cmFibGUiLCJ3cml0YWJsZSIsIlRFU1RfV09SS0VSX1BBVEgiLCJyZXNvbHZlIiwiVGVzdFJ1bm5lciIsImdsb2JhbENvbmZpZyIsImNvbnRleHQiLCJfZ2xvYmFsQ29uZmlnIiwiX2NvbnRleHQiLCJ0ZXN0cyIsIndhdGNoZXIiLCJvblN0YXJ0Iiwib25SZXN1bHQiLCJvbkZhaWx1cmUiLCJvcHRpb25zIiwic2VyaWFsIiwiX2NyZWF0ZUluQmFuZFRlc3RSdW4iLCJfY3JlYXRlUGFyYWxsZWxUZXN0UnVuIiwicHJvY2VzcyIsImVudiIsIkpFU1RfV09SS0VSX0lEIiwibXV0ZXgiLCJyZWR1Y2UiLCJwcm9taXNlIiwidGVzdCIsInRoZW4iLCJpc0ludGVycnVwdGVkIiwiQ2FuY2VsUnVuIiwicGF0aCIsImNvbmZpZyIsInJlc29sdmVyIiwidW5kZWZpbmVkIiwic2VuZE1lc3NhZ2VUb0plc3QiLCJldmVudE5hbWUiLCJhcmdzIiwiZXZlbnRFbWl0dGVyIiwiZW1pdCIsImRlZXBDeWNsaWNDb3B5Iiwia2VlcFByb3RvdHlwZSIsInJlc3VsdCIsImNhdGNoIiwiZXJyIiwiUHJvbWlzZSIsInJlc29sdmVycyIsIk1hcCIsImhhcyIsIm5hbWUiLCJzZXQiLCJzZXJpYWxpemFibGVNb2R1bGVNYXAiLCJtb2R1bGVNYXAiLCJ0b0pTT04iLCJ3b3JrZXIiLCJXb3JrZXIiLCJleHBvc2VkTWV0aG9kcyIsImZvcmtPcHRpb25zIiwic3RkaW8iLCJtYXhSZXRyaWVzIiwibnVtV29ya2VycyIsIm1heFdvcmtlcnMiLCJzZXR1cEFyZ3MiLCJzZXJpYWxpemFibGVSZXNvbHZlcnMiLCJBcnJheSIsImZyb20iLCJ2YWx1ZXMiLCJnZXRTdGRvdXQiLCJwaXBlIiwic3Rkb3V0IiwiZ2V0U3RkZXJyIiwic3RkZXJyIiwicnVuVGVzdEluV29ya2VyIiwicmVqZWN0IiwiY2hhbmdlZEZpbGVzIiwic291cmNlc1JlbGF0ZWRUb1Rlc3RzSW5DaGFuZ2VkRmlsZXMiLCJVTlNUQUJMRV9vbkN1c3RvbU1lc3NhZ2UiLCJldmVudCIsInBheWxvYWQiLCJvbkludGVycnVwdCIsIl8iLCJvbiIsInN0YXRlIiwiaW50ZXJydXB0ZWQiLCJydW5BbGxUZXN0cyIsImFsbCIsIm1hcCIsImVycm9yIiwiY2xlYW51cCIsImVuZCIsImZvcmNlRXhpdGVkIiwiY29uc29sZSIsInllbGxvdyIsInJhY2UiLCJsaXN0ZW5lciIsIm1lc3NhZ2UiLCJFcnJvciJdLCJtYXBwaW5ncyI6IkFBQUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBRUFBLE1BQU0sQ0FBQ0MsY0FBUCxDQUFzQkMsT0FBdEIsRUFBK0IsWUFBL0IsRUFBNkM7QUFDM0NDLEVBQUFBLEtBQUssRUFBRTtBQURvQyxDQUE3QztBQUdBRCxPQUFPLENBQUNFLE9BQVIsR0FBa0IsS0FBSyxDQUF2Qjs7QUFFQSxTQUFTQyxNQUFULEdBQWtCO0FBQ2hCLE1BQU1DLElBQUksR0FBR0Msc0JBQXNCLENBQUNDLE9BQU8sQ0FBQyxPQUFELENBQVIsQ0FBbkM7O0FBRUFILEVBQUFBLE1BQU0sR0FBRyxrQkFBWTtBQUNuQixXQUFPQyxJQUFQO0FBQ0QsR0FGRDs7QUFJQSxTQUFPQSxJQUFQO0FBQ0Q7O0FBRUQsU0FBU0csU0FBVCxHQUFxQjtBQUNuQixNQUFNSCxJQUFJLEdBQUdDLHNCQUFzQixDQUFDQyxPQUFPLENBQUMsVUFBRCxDQUFSLENBQW5DOztBQUVBQyxFQUFBQSxTQUFTLEdBQUcscUJBQVk7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R1MvQyxPQUFPLENBQUNnRCxJQUFSLENBQWEsQ0FBQ1QsV0FBRCxFQUFjTCxXQUFkLENBQWIsRUFBeUNuRCxJQUF6QyxDQUE4QzRELE9BQTlDLEVBQXVEQSxPQUF2RCxDQTdHVDs7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTs7O1dBZ0hBLFlBQUdwRCxTQUFILEVBQWMwRCxRQUFkLEVBQXdCO0FBQ3RCLGFBQU8sS0FBS3hELFlBQUwsQ0FBa0IyQyxFQUFsQixDQUFxQjdDLFNBQXJCLEVBQWdDMEQsUUFBaEMsQ0FBUDtBQUNEOzs7OztBQUdINUcsT0FBTyxDQUFDRSxPQUFSLEdBQWtCbUIsVUFBbEI7O0lBRU11QixTOzs7OztBQUNKLHFCQUFZaUUsT0FBWixFQUFxQjtBQUFBOztBQUFBO0FBQ25CLCtCQUFNQSxPQUFOO0FBQ0EsV0FBSzlDLElBQUwsR0FBWSxXQUFaO0FBRm1CO0FBR3BCOzs7aUNBSnFCK0MsSyIsInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSB2b2lkIDA7XG5cbmZ1bmN0aW9uIF9jaGFsaygpIHtcbiAgY29uc3QgZGF0YSA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZSgnY2hhbGsnKSk7XG5cbiAgX2NoYWxrID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBkYXRhO1xuICB9O1xuXG4gIHJldHVybiBkYXRhO1xufVxuXG5mdW5jdGlvbiBfZW1pdHRlcnkoKSB7XG4gIGNvbnN0IGRhdGEgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoJ2VtaXR0ZXJ5JykpO1xuXG4gIF9lbWl0dGVyeSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gZGF0YTtcbiAgfTtcblxuICByZXR1cm4gZGF0YTtcbn1cblxuZnVuY3Rpb24gX3Rocm9hdCgpIHtcbiAgY29uc3QgZGF0YSA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZSgndGhyb2F0JykpO1xuXG4gIF90aHJvYXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIGRhdGE7XG4gIH07XG5cbiAgcmV0dXJuIGRhdGE7XG59XG5cbmZ1bmN0aW9uIF9qZXN0VXRpbCgpIHtcbiAgY29uc3QgZGF0YSA9IHJlcXVpcmUoJ2plc3QtdXRpbCcpO1xuXG4gIF9qZXN0VXRpbCA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gZGF0YTtcbiAgfTtcblxuICByZXR1cm4gZGF0YTtcbn1cblxuZnVuY3Rpb24gX2plc3RXb3JrZXIoKSB7XG4gIGNvbnN0IGRhdGEgPSByZXF1aXJlKCdqZXN0LXdvcmtlcicpO1xuXG4gIF9qZXN0V29ya2VyID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBkYXRhO1xuICB9O1xuXG4gIHJldHVybiBkYXRhO1xufVxuXG52YXIgX3J1blRlc3QgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoJy4vcnVuVGVzdCcpKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHtcbiAgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHtkZWZhdWx0OiBvYmp9O1xufVxuXG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHZhbHVlKSB7XG4gIGlmIChrZXkgaW4gb2JqKSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7XG4gICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgd3JpdGFibGU6IHRydWVcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICBvYmpba2V5XSA9IHZhbHVlO1xuICB9XG4gIHJldHVybiBvYmo7XG59XG5cbmNvbnN0IFRFU1RfV09SS0VSX1BBVEggPSByZXF1aXJlLnJlc29sdmUoJy4vdGVzdFdvcmtlcicpO1xuXG5jbGFzcyBUZXN0UnVubmVyIHtcbiAgY29uc3RydWN0b3IoZ2xvYmFsQ29uZmlnLCBjb250ZXh0KSB7XG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsICdfZ2xvYmFsQ29uZmlnJywgdm9pZCAwKTtcblxuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCAnX2NvbnRleHQnLCB2b2lkIDApO1xuXG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsICdldmVudEVtaXR0ZXInLCBuZXcgKF9lbWl0dGVyeSgpLmRlZmF1bHQpKCkpO1xuXG4gICAgX2RlZmluZVByb3BlcnR5KFxuICAgICAgdGhpcyxcbiAgICAgICdfX1BSSVZBVEVfVU5TVEFCTEVfQVBJX3N1cHBvcnRzRXZlbnRFbWl0dGVyc19fJyxcbiAgICAgIHRydWVcbiAgICApO1xuXG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsICdpc1NlcmlhbCcsIHZvaWQgMCk7XG5cbiAgICB0aGlzLl9nbG9iYWxDb25maWcgPSBnbG9iYWxDb25maWc7XG4gICAgdGhpcy5fY29udGV4dCA9IGNvbnRleHQgfHwge307XG4gIH1cblxuICBhc3luYyBydW5UZXN0cyh0ZXN0cywgd2F0Y2hlciwgb25TdGFydCwgb25SZXN1bHQsIG9uRmFpbHVyZSwgb3B0aW9ucykge1xuICAgIHJldHVybiBhd2FpdCAob3B0aW9ucy5zZXJpYWxcbiAgICAgID8gdGhpcy5fY3JlYXRlSW5CYW5kVGVzdFJ1bih0ZXN0cywgd2F0Y2hlciwgb25TdGFydCwgb25SZXN1bHQsIG9uRmFpbHVyZSlcbiAgICAgIDogdGhpcy5fY3JlYXRlUGFyYWxsZWxUZXN0UnVuKFxuICAgICAgICAgIHRlc3RzLFxuICAgICAgICAgIHdhdGNoZXIsXG4gICAgICAgICAgb25TdGFydCxcbiAgICAgICAgICBvblJlc3VsdCxcbiAgICAgICAgICBvbkZhaWx1cmVcbiAgICAgICAgKSk7XG4gIH1cblxuICBhc3luYyBfY3JlYXRlSW5CYW5kVGVzdFJ1bih0ZXN0cywgd2F0Y2hlciwgb25TdGFydCwgb25SZXN1bHQsIG9uRmFpbHVyZSkge1xuICAgIHByb2Nlc3MuZW52LkpFU1RfV09SS0VSX0lEID0gJzEnO1xuICAgIGNvbnN0IG11dGV4ID0gKDAsIF90aHJvYXQoKS5kZWZhdWx0KSgxKTtcbiAgICByZXR1cm4gdGVzdHMucmVkdWNlKFxuICAgICAgKHByb21pc2UsIHRlc3QpID0+XG4gICAgICAgIG11dGV4KCgpID0+XG4gICAgICAgICAgcHJvbWlzZVxuICAgICAgICAgICAgLnRoZW4oYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgICBpZiAod2F0Y2hlci5pc0ludGVycnVwdGVkKCkpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgQ2FuY2VsUnVuKCk7XG4gICAgICAgICAgICAgIH0gLy8gUmVtb3ZlIGBpZihvblN0YXJ0KWAgaW4gSmVzdCAyN1xuXG4gICAgICAgICAgICAgIGlmIChvblN0YXJ0KSB7XG4gICAgICAgICAgICAgICAgYXdhaXQgb25TdGFydCh0ZXN0KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gKDAsIF9ydW5UZXN0LmRlZmF1bHQpKFxuICAgICAgICAgICAgICAgICAgdGVzdC5wYXRoLFxuICAgICAgICAgICAgICAgICAgdGhpcy5fZ2xvYmFsQ29uZmlnLFxuICAgICAgICAgICAgICAgICAgdGVzdC5jb250ZXh0LmNvbmZpZyxcbiAgICAgICAgICAgICAgICAgIHRlc3QuY29udGV4dC5yZXNvbHZlcixcbiAgICAgICAgICAgICAgICAgIHRoaXMuX2NvbnRleHQsXG4gICAgICAgICAgICAgICAgICB1bmRlZmluZWRcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICB9IC8vIGBkZWVwQ3ljbGljQ29weWAgdXNlZCBoZXJlIHRvIGF2b2lkIG1lbS1sZWFrXG5cbiAgICAgICAgICAgICAgY29uc3Qgc2VuZE1lc3NhZ2VUb0plc3QgPSAoZXZlbnROYW1lLCBhcmdzKSA9PlxuICAgICAgICAgICAgICAgIHRoaXMuZXZlbnRFbWl0dGVyLmVtaXQoXG4gICAgICAgICAgICAgICAgICBldmVudE5hbWUsXG4gICAgICAgICAgICAgICAgICAoMCwgX2plc3RVdGlsKCkuZGVlcEN5Y2xpY0NvcHkpKGFyZ3MsIHtcbiAgICAgICAgICAgICAgICAgICAga2VlcFByb3RvdHlwZTogZmFsc2VcbiAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgICBhd2FpdCB0aGlzLmV2ZW50RW1pdHRlci5lbWl0KCd0ZXN0LWZpbGUtc3RhcnQnLCBbdGVzdF0pO1xuICAgICAgICAgICAgICByZXR1cm4gKDAsIF9ydW5UZXN0LmRlZmF1bHQpKFxuICAgICAgICAgICAgICAgIHRlc3QucGF0aCxcbiAgICAgICAgICAgICAgICB0aGlzLl9nbG9iYWxDb25maWcsXG4gICAgICAgICAgICAgICAgdGVzdC5jb250ZXh0LmNvbmZpZyxcbiAgICAgICAgICAgICAgICB0ZXN0LmNvbnRleHQucmVzb2x2ZXIsXG4gICAgICAgICAgICAgICAgdGhpcy5fY29udGV4dCxcbiAgICAgICAgICAgICAgICBzZW5kTWVzc2FnZVRvSmVzdFxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIC50aGVuKHJlc3VsdCA9PiB7XG4gICAgICAgICAgICAgIGlmIChvblJlc3VsdCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBvblJlc3VsdCh0ZXN0LCByZXN1bHQpO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZXZlbnRFbWl0dGVyLmVtaXQoJ3Rlc3QtZmlsZS1zdWNjZXNzJywgW1xuICAgICAgICAgICAgICAgIHRlc3QsXG4gICAgICAgICAgICAgICAgcmVzdWx0XG4gICAgICAgICAgICAgIF0pO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIC5jYXRjaChlcnIgPT4ge1xuICAgICAgICAgICAgICBpZiAob25GYWlsdXJlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG9uRmFpbHVyZSh0ZXN0LCBlcnIpO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZXZlbnRFbWl0dGVyLmVtaXQoJ3Rlc3QtZmlsZS1mYWlsdXJlJywgW3Rlc3QsIGVycl0pO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgKSxcbiAgICAgIFByb21pc2UucmVzb2x2ZSgpXG4gICAgKTtcbiAgfVxuXG4gIGFzeW5jIF9jcmVhdGVQYXJhbGxlbFRlc3RSdW4odGVzdHMsIHdhdGNoZXIsIG9uU3RhcnQsIG9uUmVzdWx0LCBvbkZhaWx1cmUpIHtcbiAgICBjb25zdCByZXNvbHZlcnMgPSBuZXcgTWFwKCk7XG5cbiAgICBmb3IgKGNvbnN0IHRlc3Qgb2YgdGVzdHMpIHtcbiAgICAgIGlmICghcmVzb2x2ZXJzLmhhcyh0ZXN0LmNvbnRleHQuY29uZmlnLm5hbWUpKSB7XG4gICAgICAgIHJlc29sdmVycy5zZXQodGVzdC5jb250ZXh0LmNvbmZpZy5uYW1lLCB7XG4gICAgICAgICAgY29uZmlnOiB0ZXN0LmNvbnRleHQuY29uZmlnLFxuICAgICAgICAgIHNlcmlhbGl6YWJsZU1vZHVsZU1hcDogdGVzdC5jb250ZXh0Lm1vZHVsZU1hcC50b0pTT04oKVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBjb25zdCB3b3JrZXIgPSBuZXcgKF9qZXN0V29ya2VyKCkuV29ya2VyKShURVNUX1dPUktFUl9QQVRILCB7XG4gICAgICBleHBvc2VkTWV0aG9kczogWyd3b3JrZXInXSxcbiAgICAgIGZvcmtPcHRpb25zOiB7XG4gICAgICAgIHN0ZGlvOiAncGlwZSdcbiAgICAgIH0sXG4gICAgICBtYXhSZXRyaWVzOiAzLFxuICAgICAgbnVtV29ya2VyczogdGhpcy5fZ2xvYmFsQ29uZmlnLm1heFdvcmtlcnMsXG4gICAgICBzZXR1cEFyZ3M6IFtcbiAgICAgICAge1xuICAgICAgICAgIHNlcmlhbGl6YWJsZVJlc29sdmVyczogQXJyYXkuZnJvbShyZXNvbHZlcnMudmFsdWVzKCkpXG4gICAgICAgIH1cbiAgICAgIF1cbiAgICB9KTtcbiAgICBpZiAod29ya2VyLmdldFN0ZG91dCgpKSB3b3JrZXIuZ2V0U3Rkb3V0KCkucGlwZShwcm9jZXNzLnN0ZG91dCk7XG4gICAgaWYgKHdvcmtlci5nZXRTdGRlcnIoKSkgd29ya2VyLmdldFN0ZGVycigpLnBpcGUocHJvY2Vzcy5zdGRlcnIpO1xuICAgIGNvbnN0IG11dGV4ID0gKDAsIF90aHJvYXQoKS5kZWZhdWx0KSh0aGlzLl9nbG9iYWxDb25maWcubWF4V29ya2Vycyk7IC8vIFNlbmQgdGVzdCBzdWl0ZXMgdG8gd29ya2VycyBjb250aW51b3VzbHkgaW5zdGVhZCBvZiBhbGwgYXQgb25jZSB0byB0cmFja1xuICAgIC8vIHRoZSBzdGFydCB0aW1lIG9mIGluZGl2aWR1YWwgdGVzdHMuXG5cbiAgICBjb25zdCBydW5UZXN0SW5Xb3JrZXIgPSB0ZXN0ID0+XG4gICAgICBtdXRleChhc3luYyAoKSA9PiB7XG4gICAgICAgIGlmICh3YXRjaGVyLmlzSW50ZXJydXB0ZWQoKSkge1xuICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdCgpO1xuICAgICAgICB9IC8vIFJlbW92ZSBgaWYob25TdGFydClgIGluIEplc3QgMjdcblxuICAgICAgICBpZiAob25TdGFydCkge1xuICAgICAgICAgIGF3YWl0IG9uU3RhcnQodGVzdCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgYXdhaXQgdGhpcy5ldmVudEVtaXR0ZXIuZW1pdCgndGVzdC1maWxlLXN0YXJ0JywgW3Rlc3RdKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHByb21pc2UgPSB3b3JrZXIud29ya2VyKHtcbiAgICAgICAgICBjb25maWc6IHRlc3QuY29udGV4dC5jb25maWcsXG4gICAgICAgICAgY29udGV4dDoge1xuICAgICAgICAgICAgLi4udGhpcy5fY29udGV4dCxcbiAgICAgICAgICAgIGNoYW5nZWRGaWxlczpcbiAgICAgICAgICAgICAgdGhpcy5fY29udGV4dC5jaGFuZ2VkRmlsZXMgJiZcbiAgICAgICAgICAgICAgQXJyYXkuZnJvbSh0aGlzLl9jb250ZXh0LmNoYW5nZWRGaWxlcyksXG4gICAgICAgICAgICBzb3VyY2VzUmVsYXRlZFRvVGVzdHNJbkNoYW5nZWRGaWxlczpcbiAgICAgICAgICAgICAgdGhpcy5fY29udGV4dC5zb3VyY2VzUmVsYXRlZFRvVGVzdHNJbkNoYW5nZWRGaWxlcyAmJlxuICAgICAgICAgICAgICBBcnJheS5mcm9tKHRoaXMuX2NvbnRleHQuc291cmNlc1JlbGF0ZWRUb1Rlc3RzSW5DaGFuZ2VkRmlsZXMpXG4gICAgICAgICAgfSxcbiAgICAgICAgICBnbG9iYWxDb25maWc6IHRoaXMuX2dsb2JhbENvbmZpZyxcbiAgICAgICAgICBwYXRoOiB0ZXN0LnBhdGhcbiAgICAgICAgfSk7XG5cbiAgICAgICAgaWYgKHByb21pc2UuVU5TVEFCTEVfb25DdXN0b21NZXNzYWdlKSB7XG4gICAgICAgICAgLy8gVE9ETzogR2V0IGFwcHJvcHJpYXRlIHR5cGUgZm9yIGBvbkN1c3RvbU1lc3NhZ2VgXG4gICAgICAgICAgcHJvbWlzZS5VTlNUQUJMRV9vbkN1c3RvbU1lc3NhZ2UoKFtldmVudCwgcGF5bG9hZF0pID0+IHtcbiAgICAgICAgICAgIHRoaXMuZXZlbnRFbWl0dGVyLmVtaXQoZXZlbnQsIHBheWxvYWQpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHByb21pc2U7XG4gICAgICB9KTtcblxuICAgIGNvbnN0IG9uSW50ZXJydXB0ID0gbmV3IFByb21pc2UoKF8sIHJlamVjdCkgPT4ge1xuICAgICAgd2F0Y2hlci5vbignY2hhbmdlJywgc3RhdGUgPT4ge1xuICAgICAgICBpZiAoc3RhdGUuaW50ZXJydXB0ZWQpIHtcbiAgICAgICAgICByZWplY3QobmV3IENhbmNlbFJ1bigpKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSk7XG4gICAgY29uc3QgcnVuQWxsVGVzdHMgPSBQcm9taXNlLmFsbChcbiAgICAgIHRlc3RzLm1hcCh0ZXN0ID0+XG4gICAgICAgIHJ1blRlc3RJbldvcmtlcih0ZXN0KVxuICAgICAgICAgIC50aGVuKHJlc3VsdCA9PiB7XG4gICAgICAgICAgICBpZiAob25SZXN1bHQpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIG9uUmVzdWx0KHRlc3QsIHJlc3VsdCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiB0aGlzLmV2ZW50RW1pdHRlci5lbWl0KCd0ZXN0LWZpbGUtc3VjY2VzcycsIFt0ZXN0LCByZXN1bHRdKTtcbiAgICAgICAgICB9KVxuICAgICAgICAgIC5jYXRjaChlcnJvciA9PiB7XG4gICAgICAgICAgICBpZiAob25GYWlsdXJlKSB7XG4gICAgICAgICAgICAgIHJldHVybiBvbkZhaWx1cmUodGVzdCwgZXJyb3IpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5ldmVudEVtaXR0ZXIuZW1pdCgndGVzdC1maWxlLWZhaWx1cmUnLCBbdGVzdCwgZXJyb3JdKTtcbiAgICAgICAgICB9KVxuICAgICAgKVxuICAgICk7XG5cbiAgICBjb25zdCBjbGVhbnVwID0gYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3Qge2ZvcmNlRXhpdGVkfSA9IGF3YWl0IHdvcmtlci5lbmQoKTtcblxuICAgICAgaWYgKGZvcmNlRXhpdGVkKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgX2NoYWxrKCkuZGVmYXVsdC55ZWxsb3coXG4gICAgICAgICAgICAnQSB3b3JrZXIgcHJvY2VzcyBoYXMgZmFpbGVkIHRvIGV4aXQgZ3JhY2VmdWxseSBhbmQgaGFzIGJlZW4gZm9yY2UgZXhpdGVkLiAnICtcbiAgICAgICAgICAgICAgJ1RoaXMgaXMgbGlrZWx5IGNhdXNlZCBieSB0ZXN0cyBsZWFraW5nIGR1ZSB0byBpbXByb3BlciB0ZWFyZG93bi4gJyArXG4gICAgICAgICAgICAgICdUcnkgcnVubmluZyB3aXRoIC0tZGV0ZWN0T3BlbkhhbmRsZXMgdG8gZmluZCBsZWFrcy4gJyArXG4gICAgICAgICAgICAgICdBY3RpdmUgdGltZXJzIGNhbiBhbHNvIGNhdXNlIHRoaXMsIGVuc3VyZSB0aGF0IC51bnJlZigpIHdhcyBjYWxsZWQgb24gdGhlbS4nXG4gICAgICAgICAgKVxuICAgICAgICApO1xuICAgICAgfVxuICAgIH07XG5cbiAgICByZXR1cm4gUHJvbWlzZS5yYWNlKFtydW5BbGxUZXN0cywgb25JbnRlcnJ1cHRdKS50aGVuKGNsZWFudXAsIGNsZWFudXApO1xuICB9XG5cbiAgb24oZXZlbnROYW1lLCBsaXN0ZW5lcikge1xuICAgIHJldHVybiB0aGlzLmV2ZW50RW1pdHRlci5vbihldmVudE5hbWUsIGxpc3RlbmVyKTtcbiAgfVxufVxuXG5leHBvcnRzLmRlZmF1bHQgPSBUZXN0UnVubmVyO1xuXG5jbGFzcyBDYW5jZWxSdW4gZXh0ZW5kcyBFcnJvciB7XG4gIGNvbnN0cnVjdG9yKG1lc3NhZ2UpIHtcbiAgICBzdXBlcihtZXNzYWdlKTtcbiAgICB0aGlzLm5hbWUgPSAnQ2FuY2VsUnVuJztcbiAgfVxufVxuIl19